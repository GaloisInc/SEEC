#lang seec
;; Abstract -> Heap -> Freelist
;; May be renamed demo, as compilation is just chaining abstract-to-heap and heap-to-freelist 
;; TODO : will need to bridge together w/o using hl (or using hl all the way)
(require racket/format)
(require seec/private/util)
(require seec/private/monad)

(require (file "lib.rkt"))
(require (file "heap-lang-hl.rkt"))
(require (file "heap-abstract-lang-hl.rkt"))
(require (file "freelist-lang.rkt"))
(require (file "heap-to-freelist-compiler.rkt"))
(require (file "abstract-to-heap-hl-compiler.rkt"))


; Compile to heap-hl
(define (manual-full-test0)
  (begin
    (define ab0 (abstract-model value 1))
    (define ab1 (abstract-model value 1))
    (define ab2 (abstract-model value 1))
    (define ab3 (abstract-model value 1))
    (define ab* (abstract-model (cons ,ab0 (cons ,ab1 (cons ,ab2 (cons ,ab3 nil))))))
    (define ablock (abstract-model block 3))
    (define ah* (abstract-model (cons ,ablock nil)))
    (define as* (abstract-model (,ab* ,ah*)))
    (let*-values
        ([(p* nondet*) (capture-nondeterminism #:nondet #t (generate-permutation-fl 2 1))])
      (define s* (make-state-struct (test-abs-into-heap-fl p* as*)))
      (define ai* (abstract-model action 3))
      (define as+* (abs-interpret-action ai* as*))
      (define i* (compile-abs-action ai* p*))
      (define s+* (interpret-action i* s*))
      (define sol (verify (assert ((bounded-equiv-state 3) as+* s+*))))
      (if (unsat? sol)
          (displayln "unsat")
          (begin
            (displayln "sat")
            (define as (concretize as* sol))
            (define ai (concretize ai* sol))
            (define i (concretize i* sol))
            (define s (concretize s* sol))
            (define s+ (interpret-action i s))
            (define as+ (abs-interpret-action i as))
            (displayln "Over state")
            (display-abs-state as)
            (displayln "compiled as state")
            (display-state s)
            (display "Action ")
            (displayln ai)
            (displayln i)
            (displayln "Results in abstract.state :")
            (display-abs-state as+)
            (displayln "and heap.state :")
            (display-state s+)
            (displayln "which are equivalent?")
            (displayln ((bounded-equiv-state 3) as+ s+)))))))

; Compile all the way to freelist
(define (manual-full-test1)
  (begin
    (define ab0 (abstract-model value 1))
    (define ab1 (abstract-model value 1))
    (define ab2 (abstract-model value 1))
    (define ab3 (abstract-model value 1))
    (define ab* (abstract-model (cons ,ab0 (cons ,ab1 (cons ,ab2 (cons ,ab3 nil))))))
    (define ablock (abstract-model block 3))
    (define ah* (abstract-model (cons ,ablock nil)))
    (define as* (abstract-model (,ab* ,ah*)))
        (let*-values ; Note: I don't need the p later since we only care about the actions over heap.state, and use abstract to restrict the space of states
        ([(p* nondet*) (capture-nondeterminism #:nondet #t (generate-permutation-fl 2 1))])
          (define s* (make-state-struct (test-abs-into-heap-fl p* as*)))
          (define fl* (compile-heap-to-freelist s*))
          ;(define ai* (abstract-model action 3))
          ; (define as+* (abs-interpret-action ai* as*))
          (define i* (heap-model interaction 3)) ; (compile-abs-action ai* p*))
          (define s+* (interpret-interaction i* s*))
          (define fi* (compile-interaction i*))
          (define fl+* (freelist-interaction fi* fl*))      
          (define sol (verify (assert (equal? (compile-heap-to-freelist s+*) fl+*))))
          (if (unsat? sol)
              (displayln "unsat")
              (begin
                (displayln "sat")
                (define as (concretize as* sol))
                (define i (concretize i* sol))
                (define fi (concretize fi* sol))
                (define s (concretize s* sol))
                (define s+ (interpret-interaction i s))
                (define fl (concretize fl* sol))
                (define fl+ (freelist-interaction fi fl))
                (displayln "Over state")
                (display-abs-state as)
                (displayln "compiled as state")
                (display-state s)
                (displayln "with freelist")
                (displayln fl)
                (display "Action ")
                (displayln i)
                (displayln "Results in heap.state :")
                (display-state s+)
                (displayln "and free list :")
                (displayln fl+))))))
